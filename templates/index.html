<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìÅ Restructuring</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="app">
        <header class="app-header">
            <h1>Google Drive Takeout Restructuring</h1>
            <p class="subtitle">This app automatically extracts and reorganizes the ZIP files from a Google Takeout export, restoring your original Google Drive folder structure so you can easily re-upload it or keep it as a clean local backup.</p>
        </header>

        <main class="app-main">
            <!-- Main Interface -->
            <div class="interface" id="main-interface">
                <div class="panel-grid">
                    <!-- Left Panel: File Selection -->
                    <div class="panel">
                        <div class="panel-header">
                            <h2>Select Source Folder</h2>
                            <p class="step-label">Step 1: üìÅ Add path to Takeout.zip files</p>
                        </div>
                        
                        <div class="drop-zone" id="drop-zone">
                            <div class="drop-content">
                                <span class="drop-icon">üìÅ</span>
                                <p>Drag Takeout.zip Files here</p>
                            </div>
                        </div>
                        
                        <div class="file-actions">
                            <input type="text" id="folder-path" placeholder="Enter folder path or use buttons below..." 
                                   style="width: 100%; padding: 12px; margin-bottom: 12px; border: 1px solid #dee2e6; border-radius: 6px; font-family: 'Poppins', sans-serif;" 
                                   oninput="validatePath()">
                            <button type="button" class="btn-primary" onclick="selectTakeoutFolder()">
                                Browse Folder...
                            </button>
                            <div class="path-display" id="path-display">
                                <div class="path-label-header">Selected Path:</div>
                                <div class="path-label">/volume/file/path/example...</div>
                            </div>
                        </div>
                        
                        <!-- Found ZIP files list -->
                        <div class="file-list" id="file-list" style="display: none;">
                            <h3>üìÅ Found ZIP Files</h3>
                            <div class="zip-list" id="zip-list">
                                <!-- ZIP files will be populated here -->
                            </div>
                        </div>
                    </div>

                    <!-- Right Panel: Settings -->
                    <div class="panel">
                        <div class="panel-header">
                            <h2>Configure Output Settings</h2>
                            <p class="step-label">Step 2: üîß Build Settings</p>
                        </div>
                        
                        <div class="settings-form">
                            <div class="setting-item">
                                <label class="checkbox-row" for="dry-run">
                                    <input type="checkbox" id="dry-run">
                                    <span class="checkbox-label">‚ùå Dry Run (Preview Only)</span>
                                </label>
                                <div style="margin-left: 30px; margin-top: 8px; font-size: 0.85rem; color: #6c757d; line-height: 1.4;">
                                    üìã Shows what would happen without moving files<br>
                                    ‚ö° Fast preview to verify your setup is correct<br>
                                    üîç Detects conflicts and issues before real execution
                                </div>
                            </div>
                            
                            <div class="setting-item">
                                <label class="checkbox-row" for="verify-files">
                                    <input type="checkbox" id="verify-files">
                                    <span class="checkbox-label">üîê File Verification (Recommended)</span>
                                </label>
                                <div style="margin-left: 30px; margin-top: 8px; font-size: 0.85rem; color: #6c757d; line-height: 1.4;">
                                    üõ°Ô∏è Verifies each file with hash checking after copy<br>
                                    ‚è±Ô∏è Takes longer but ensures 100% data integrity<br>
                                    üíé Recommended for important files (300GB+ datasets)
                                </div>
                            </div>
                            
                            <div class="setting-item">
                                <h3>üìã Handle File Conflicts</h3>
                                <div class="conflict-options">
                                    <label class="radio-row" for="conflict-skip">
                                        <input type="radio" id="conflict-skip" name="conflict" value="skip">
                                        <span class="radio-label">Skip Duplicates</span>
                                    </label>
                                    <label class="radio-row" for="conflict-rename">
                                        <input type="radio" id="conflict-rename" name="conflict" value="rename" checked>
                                        <span class="radio-label">Rename (auto-suffix)</span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="output-section">
                                <p class="step-label">Step 3:  üíæ Select file export location</p>
                                <button type="button" class="btn-primary" onclick="selectExportFolder()">
                                    Select Export Folder
                                </button>
                                <div class="path-display" id="export-path-display">
                                    <div class="path-label-header">Export Path:</div>
                                    <div class="path-label">/volume/file/path/example...</div>
                                </div>
                            </div>
                            
                            <button type="button" class="btn-action" id="start-btn" 
                                    onclick="startProcessing()" disabled>
                                Start Restructuring
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Progress Interface -->
            <div class="interface" id="progress-interface" style="display: none;">
                <div class="progress-panel">
                    <div class="panel-header">
                        <h2>Processing Files</h2>
                        <button type="button" class="btn-small" onclick="showLogs()">
                            View Logs
                        </button>
                    </div>
                    
                    <div class="progress-section">
                        <div class="current-operation" id="current-operation">
                            Initializing...
                        </div>
                        
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                        </div>
                        
                        <div class="progress-stats">
                            <span id="progress-text">0% - Starting...</span>
                            <span id="operation-status">Ready</span>
                        </div>
                    </div>
                    
                    <div class="stats-grid" id="stats-display" style="display: none;">
                        <div class="stat">
                            <div class="stat-value" id="total-files">0</div>
                            <div class="stat-label">Total Files</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="processed-files">0</div>
                            <div class="stat-label">Processed</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="skipped-files">0</div>
                            <div class="stat-label">Skipped</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="error-count">0</div>
                            <div class="stat-label">Errors</div>
                        </div>
                    </div>
                    
                    <div class="action-buttons">
                        <button type="button" class="btn" onclick="cancelOperation()">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>

            <!-- Dry Run Results Interface -->
            <div class="interface" id="dry-run-interface" style="display: none;">
                <div class="completion-panel">
                    <div class="panel-header">
                        <h2>üìã Dry Run Complete - Preview Results</h2>
                        <p style="color: #6c757d; margin-top: 8px; font-size: 0.9rem;">No files were moved. This shows what WOULD happen during real execution.</p>
                    </div>
                    
                    <div class="completion-summary" id="dry-run-summary">
                        <!-- Dry run results will be populated here -->
                    </div>
                    
                    <div class="action-buttons">
                        <button type="button" class="btn-primary" onclick="proceedWithRealExecution()" style="background: #28a745;">
                            ‚ñ∂Ô∏è Proceed with Real Execution
                        </button>
                        <button type="button" class="btn" onclick="showMainInterface()">
                            ‚Üê Back to Settings
                        </button>
                        <button type="button" class="btn" onclick="downloadLogs()">
                            Download Preview Logs
                        </button>
                    </div>
                </div>
            </div>

            <!-- Completion Interface -->
            <div class="interface" id="completion-interface" style="display: none;">
                <div class="completion-panel">
                    <div class="panel-header">
                        <h2>‚úÖ Processing Complete</h2>
                    </div>
                    
                    <div class="completion-summary" id="completion-summary">
                        <!-- Results will be populated here -->
                    </div>
                    
                    <div class="action-buttons">
                        <button type="button" class="btn-primary" onclick="openOutputFolder()">
                            Open Output Folder
                        </button>
                        <button type="button" class="btn" onclick="cleanupTempFiles()">
                            Clean Temp Files
                        </button>
                        <button type="button" class="btn" onclick="downloadLogs()">
                            Download Logs
                        </button>
                        <button type="button" class="btn" onclick="startOver()">
                            Process More Files
                        </button>
                    </div>
                </div>
            </div>
        </main>

        <!-- Error Toast -->
        <div class="toast error-toast" id="error-toast" style="display: none;">
            <span id="error-message">Error message</span>
            <button type="button" onclick="hideError()">√ó</button>
        </div>
    </div>

    <script>
        // Global state
        let currentOperation = null;
        let progressInterval = null;
        let foundZips = [];
        let spaceInfo = {};
        let sourcePath = '';
        let exportPath = '';
        let isPickerActive = false;  // Track if file picker is open

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupDropZone();
            updateStartButton();
            setupFormInteractions();
            checkForRecovery();
        });
        
        // Enhanced state recovery with localStorage backup
        async function checkForRecovery() {
            // Always try to restore client state first (instant feedback)
            restoreClientState();
            
            // Try to connect to server with retries
            let recovery = null;
            let attempts = 0;
            const maxAttempts = 3;
            
            while (attempts < maxAttempts && !recovery) {
                attempts++;
                try {
                    // Try to get server state with timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 2000 + attempts * 1000); // Increasing timeout
                    
                    const response = await fetch('/recovery-info', {
                        signal: controller.signal,
                        cache: 'no-cache'
                    });
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                    }
                    
                    recovery = await response.json();
                    break; // Success - exit retry loop
                    
                } catch (error) {
                    console.log(`Attempt ${attempts}/${maxAttempts} failed:`, error.message);
                    
                    if (attempts < maxAttempts) {
                        // Wait before retrying (exponential backoff)
                        await new Promise(resolve => setTimeout(resolve, attempts * 500));
                    }
                }
            }
            
            if (recovery) {
                console.log('‚úÖ Server state recovered:', recovery);
                
                if (recovery.has_recovery && recovery.primary_operation) {
                    const operation = recovery.primary_operation;
                    
                    // Check if operation is likely still active
                    if (operation.is_likely_active) {
                        console.log(`üîÑ Resuming active operation: ${operation.operation_id}`);
                        
                        // Set current operation and switch to progress interface
                        currentOperation = operation.operation_id;
                        showProgressInterface();
                        
                        // Update UI with current state
                        updateProgress({
                            current_operation: operation.current_operation || 'Processing...',
                            progress_percent: operation.progress || 0,
                            current_file: operation.current_file || 'Resuming...',
                            status: operation.status || 'processing',
                            stats: operation.stats || {}
                        });
                        
                        // Start monitoring
                        startProgressMonitoring();
                        
                        // Show recovery notification
                        showRecoveryNotification(operation);
                        
                        console.log('‚úÖ Successfully resumed active operation');
                        
                    } else {
                        // Operation appears stale - offer to clean up or continue
                        showStaleOperationDialog(operation);
                    }
                    
                } else if (recovery.has_saved_settings && recovery.settings) {
                    // No active operation, but restore saved settings from server
                    const serverSettings = recovery.settings;
                    
                    // Merge server settings with client state (server takes precedence for paths)
                    if (serverSettings.source_path && serverSettings.source_path !== sourcePath) {
                        sourcePath = serverSettings.source_path;
                        document.getElementById('folder-path').value = serverSettings.source_path;
                        updatePathDisplay('path-display', serverSettings.source_path);
                        // Re-validate the path to get current ZIP file list
                        await validatePath();
                    }
                    
                    if (serverSettings.output_path && serverSettings.output_path !== exportPath) {
                        exportPath = serverSettings.output_path;
                        updatePathDisplay('export-path-display', serverSettings.output_path);
                    }
                    
                    // Restore other settings
                    if (serverSettings.dry_run !== undefined) {
                        document.getElementById('dry-run').checked = serverSettings.dry_run;
                        updateCheckboxVisual();
                    }
                    
                    if (serverSettings.verify !== undefined) {
                        document.getElementById('verify-files').checked = serverSettings.verify;
                        updateVerifyVisual();
                    }
                    
                    if (serverSettings.conflict_mode) {
                        const radio = document.querySelector(`input[name="conflict"][value="${serverSettings.conflict_mode}"]`);
                        if (radio) {
                            radio.checked = true;
                            updateRadioVisuals();
                        }
                    }
                    
                    updateStartButton();
                    console.log('‚úÖ Restored server settings');
                }
                
            } else {
                // Failed to connect to server after retries
                console.log('üîå Server not available after retries - continuing with local state');
                
                // Only show error if we don't have any local state to work with
                const hasLocalState = sourcePath || exportPath || foundZips.length > 0;
                if (!hasLocalState) {
                    showError('Server not available. Using offline mode with limited features.', 4000);
                }
            }
        }
        
        // Save client state to localStorage for backup recovery
        function saveClientState() {
            const state = {
                sourcePath: sourcePath,
                exportPath: exportPath,
                foundZips: foundZips,
                currentOperation: currentOperation,
                lastSaved: new Date().toISOString()
            };
            
            try {
                localStorage.setItem('gdrive_consolidator_state', JSON.stringify(state));
            } catch (e) {
                console.log('Could not save to localStorage:', e);
            }
        }
        
        // Restore client state from localStorage
        function restoreClientState() {
            try {
                const saved = localStorage.getItem('gdrive_consolidator_state');
                if (saved) {
                    const state = JSON.parse(saved);
                    
                    // Only restore if recent (within 24 hours)
                    const saveTime = new Date(state.lastSaved);
                    const now = new Date();
                    const hoursSince = (now - saveTime) / (1000 * 60 * 60);
                    
                    if (hoursSince < 24) {
                        if (state.sourcePath) {
                            sourcePath = state.sourcePath;
                            document.getElementById('folder-path').value = state.sourcePath;
                            updatePathDisplay('path-display', state.sourcePath);
                        }
                        if (state.exportPath) {
                            exportPath = state.exportPath;
                            updatePathDisplay('export-path-display', state.exportPath);
                        }
                        if (state.foundZips) {
                            foundZips = state.foundZips;
                            displayFoundZips();
                        }
                        
                        updateStartButton();
                        console.log('‚úÖ Restored client state from localStorage');
                    }
                }
            } catch (e) {
                console.log('Could not restore from localStorage:', e);
            }
        }
        
        // Show recovery notification
        function showRecoveryNotification(operation) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
                background: #d4edda; border: 1px solid #c3e6cb; color: #155724;
                padding: 15px 25px; border-radius: 8px; z-index: 1000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15); font-family: 'Poppins', sans-serif;
                max-width: 500px; text-align: center;
            `;
            
            notification.innerHTML = `
                üîÑ <strong>Operation Resumed</strong><br>
                <small>Continuing ${operation.dry_run ? 'dry run' : 'processing'} from ${operation.progress}% - 
                ${operation.minutes_since_activity}min since last activity</small>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 4 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 4000);
        }
        
        // Show dialog for stale operations
        function showStaleOperationDialog(operation) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center;
                z-index: 10000; font-family: 'Poppins', sans-serif;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 12px; max-width: 500px; text-align: center;">
                    <h3 style="color: #ffc107; margin-bottom: 20px;">‚ö†Ô∏è Stale Operation Found</h3>
                    <p style="margin-bottom: 20px; line-height: 1.5;">
                        Found an operation that hasn't been active for ${operation.minutes_since_activity} minutes:<br>
                        <strong>${operation.operation_id}</strong><br><br>
                        Last status: ${operation.status} (${operation.progress}% complete)
                    </p>
                    <div style="display: flex; gap: 12px; justify-content: center;">
                        <button onclick="this.closest('div[style*=position]').remove(); resumeStaleOperation('${operation.operation_id}')" 
                                style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Try Resume
                        </button>
                        <button onclick="this.closest('div[style*=position]').remove(); cleanupStaleOperation('${operation.operation_id}')" 
                                style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Clean Up
                        </button>
                        <button onclick="this.closest('div[style*=position]').remove()" 
                                style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Ignore
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Resume a stale operation
        async function resumeStaleOperation(operationId) {
            currentOperation = operationId;
            showProgressInterface();
            startProgressMonitoring();
            showError('‚è≥ Attempting to resume operation...', 3000);
        }
        
        // Clean up a stale operation
        async function cleanupStaleOperation(operationId) {
            try {
                const response = await fetch(`/cancel/${operationId}`, { method: 'POST' });
                const result = await response.json();
                
                if (result.success) {
                    showError('‚úÖ Stale operation cleaned up successfully', 3000);
                } else {
                    showError('‚ö†Ô∏è Could not clean up stale operation: ' + result.message, 5000);
                }
            } catch (error) {
                showError('‚ö†Ô∏è Error cleaning up stale operation: ' + error.message, 5000);
            }
        }
        
        // Restore form settings from saved state
        function restoreSettings(settings) {
            if (settings.source_path) {
                sourcePath = settings.source_path;
                document.getElementById('folder-path').value = settings.source_path;
                updatePathDisplay('source-path-display', settings.source_path);
            }
            
            if (settings.output_path) {
                exportPath = settings.output_path;
                document.getElementById('export-path').value = settings.output_path;
                updatePathDisplay('export-path-display', settings.output_path);
            }
            
            if (settings.dry_run !== undefined) {
                document.getElementById('dry-run').checked = settings.dry_run;
                updateCheckboxVisual();
            }
            
            if (settings.verify !== undefined) {
                document.getElementById('verify-files').checked = settings.verify;
                updateVerifyVisual();
            }
            
            if (settings.conflict_mode) {
                const radio = document.querySelector(`input[name="conflict"][value="${settings.conflict_mode}"]`);
                if (radio) {
                    radio.checked = true;
                    updateRadioVisuals();
                }
            }
            
            updateStartButton();
            console.log('‚úÖ Restored previous settings');
        }
        
        // Update progress display with current data
        function updateProgressDisplay(data) {
            if (data.progress_percent !== undefined) {
                const progressBar = document.querySelector('.progress-bar');
                const progressText = document.querySelector('.progress-percent');
                
                if (progressBar) {
                    progressBar.style.width = `${data.progress_percent}%`;
                }
                if (progressText) {
                    progressText.textContent = `${Math.round(data.progress_percent)}%`;
                }
            }
            
            if (data.current_file) {
                const currentFileEl = document.querySelector('.current-file');
                if (currentFileEl) {
                    currentFileEl.textContent = data.current_file;
                }
            }
            
            if (data.status) {
                const statusEl = document.getElementById('current-operation');
                if (statusEl) {
                    const statusMap = {
                        'processing': 'Processing files...',
                        'consolidating': 'Consolidating structure...',
                        'extracting': 'Extracting ZIP files...',
                        'started': 'Starting operation...'
                    };
                    statusEl.textContent = statusMap[data.status] || data.status;
                }
            }
        }

        // Setup form interactions
        function setupFormInteractions() {
            // Update radio button visual state
            const radioButtons = document.querySelectorAll('input[name="conflict"]');
            radioButtons.forEach(radio => {
                radio.addEventListener('change', updateRadioVisuals);
            });
            
            // Update checkbox visual state
            const dryRunCheckbox = document.getElementById('dry-run');
            const verifyCheckbox = document.getElementById('verify-files');
            
            dryRunCheckbox.addEventListener('change', updateCheckboxVisual);
            verifyCheckbox.addEventListener('change', updateVerifyVisual);
            
            // Initial visual updates
            updateRadioVisuals();
            updateCheckboxVisual();
            updateVerifyVisual();
        }

        // Update checkbox visual indicator
        function updateCheckboxVisual() {
            const checkbox = document.getElementById('dry-run');
            const label = checkbox.parentElement.querySelector('.checkbox-label');
            
            if (checkbox.checked) {
                label.textContent = 'Dry Run (‚úÖ Preview Only)';
            } else {
                label.textContent = 'Dry Run (‚ùå Real Execution)';
            }
        }
        
        // Update verify checkbox visual indicator
        function updateVerifyVisual() {
            const checkbox = document.getElementById('verify-files');
            const label = checkbox.parentElement.querySelector('.checkbox-label');
            
            if (checkbox.checked) {
                label.textContent = 'File Verification (‚úÖ Recommended)';
            } else {
                label.textContent = 'File Verification (‚ùå Dangerous)';
            }
        }

        // Update radio button visual indicators
        function updateRadioVisuals() {
            // Radio buttons now use native styling, no custom visual indicators needed
            // The browser handles the visual state automatically
        }

        // Drop zone setup for path detection (NO file upload)
        function setupDropZone() {
            const dropZone = document.getElementById('drop-zone');
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                
                // Get folder path from dropped file
                const items = e.dataTransfer.items;
                if (items && items.length > 0) {
                    const item = items[0];
                    if (item.kind === 'file') {
                        const file = item.getAsFile();
                        // Extract directory path from file
                        let folderPath = '';
                        
                        if (file.webkitRelativePath) {
                            // If from folder selection, get parent folder name only
                            const pathParts = file.webkitRelativePath.split('/');
                            pathParts.pop(); // Remove filename
                            const folderName = pathParts[pathParts.length - 1] || pathParts[0];
                            // Prompt for full path since browser can't provide it
                            folderPath = prompt(`Enter the full path to "${folderName}":`, `/Volumes/Creator Pro/${folderName}`);
                        } else {
                            // Single file - prompt for folder path
                            const fileName = file.name;
                            folderPath = prompt(`Enter the full folder path containing "${fileName}":`, '/Volumes/Creator Pro/');
                        }
                        
                        if (folderPath) {
                            document.getElementById('folder-path').value = folderPath;
                            sourcePath = folderPath;
                            validatePath();
                        }
                    }
                }
            });
        }

        // Safe directory picker wrapper
        async function safeShowDirectoryPicker() {
            if (isPickerActive) {
                throw new Error('File picker is already open. Please close it first.');
            }
            
            if (!('showDirectoryPicker' in window)) {
                throw new Error('Directory picker not supported in this browser');
            }
            
            try {
                isPickerActive = true;
                
                // Disable all picker buttons while active
                const pickerButtons = document.querySelectorAll('button[onclick*="select"]');
                pickerButtons.forEach(btn => {
                    btn.disabled = true;
                    btn.style.opacity = '0.6';
                });
                
                const dirHandle = await window.showDirectoryPicker();
                return dirHandle;
            } finally {
                isPickerActive = false;
                
                // Re-enable picker buttons
                const pickerButtons = document.querySelectorAll('button[onclick*="select"]');
                pickerButtons.forEach(btn => {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                });
            }
        }

        // Enhanced folder selection using native dialog
        async function selectTakeoutFolder() {
            try {
                if ('showDirectoryPicker' in window) {
                    const dirHandle = await safeShowDirectoryPicker();
                    // Note: Web API doesn't give full path for security reasons
                    // User needs to type the full path manually
                    const fullPath = prompt(`Enter the full path to "${dirHandle.name}":
(Browser security prevents auto-detection of full paths)`, `/Volumes/Creator Pro/${dirHandle.name}`);
                    if (fullPath) {
                        sourcePath = fullPath;
                        document.getElementById('folder-path').value = fullPath;
                        updatePathDisplay('path-display', fullPath);
                        await validatePath();
                    }
                } else {
                    const path = prompt('Enter the full path to your Takeout folder:', '/Volumes/Creator Pro/');
                    if (path) {
                        sourcePath = path;
                        document.getElementById('folder-path').value = path;
                        updatePathDisplay('path-display', path);
                        await validatePath();
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('User cancelled folder selection');
                } else if (error.message.includes('picker is already open')) {
                    showError('Please close the current file picker before opening another one.', 3000);
                } else {
                    showError(`Error selecting folder: ${error.message}`);
                }
            }
        }

        // Select export folder
        async function selectExportFolder() {
            try {
                if ('showDirectoryPicker' in window) {
                    const dirHandle = await safeShowDirectoryPicker();
                    // Prompt for full path since browser can't provide it
                    const fullPath = prompt(`Enter the full path to "${dirHandle.name}":\n(Or create a new folder in this location)`, `/Volumes/Creator Pro/${dirHandle.name}`);
                    if (fullPath) {
                        exportPath = fullPath;
                        updatePathDisplay('export-path-display', fullPath);
                        saveClientState(); // Save export path
                    }
                } else {
                    const path = prompt('Enter the full path for export folder:', '/Volumes/Creator Pro/output');
                    if (path) {
                        exportPath = path;
                        updatePathDisplay('export-path-display', path);
                        saveClientState(); // Save export path
                    }
                }
                updateStartButton();
            } catch (error) {
                if (error.name !== 'AbortError') {
                    showError(`Error selecting export folder: ${error.message}`);
                }
            }
        }

        // Update path display with full path
        function updatePathDisplay(elementId, path) {
            const display = document.getElementById(elementId);
            const label = display.querySelector('.path-label');
            
            if (path && path.trim()) {
                // Show full path with proper formatting
                label.textContent = path;
                label.style.color = '#007bff';
                label.style.fontWeight = '500';
                
                // Add title attribute for hover tooltip of full path
                label.title = path;
            } else {
                label.textContent = 'No path selected';
                label.style.color = '#adb5bd';
                label.style.fontWeight = '400';
                label.title = '';
            }
        }

        // Validate selected directory using File System Access API
        async function validateSelectedDirectory(dirHandle) {
            try {
                const zipFiles = [];
                for await (const [name, handle] of dirHandle.entries()) {
                    if (handle.kind === 'file' && name.toLowerCase().endsWith('.zip')) {
                        const file = await handle.getFile();
                        zipFiles.push({
                            name: file.name,
                            size: file.size,
                            path: name
                        });
                    }
                }
                
                foundZips = zipFiles;
                displayFoundZips();
                updateStartButton();
                
                if (zipFiles.length > 0) {
                    showSuccess(`Found ${zipFiles.length} ZIP files`);
                } else {
                    showError('No ZIP files found in selected folder');
                }
            } catch (error) {
                showError(`Error reading directory: ${error.message}`);
            }
        }

        // Validate path and find ZIP files
        async function validatePath() {
            const path = document.getElementById('folder-path').value.trim();
            if (!path) {
                foundZips = [];
                displayFoundZips();
                updateStartButton();
                saveClientState(); // Save state changes
                return;
            }

            try {
                const response = await fetch('/validate-path', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: path })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    foundZips = result.zip_files;
                    spaceInfo = result.space_info || {};
                    sourcePath = path;
                    displayFoundZips();
                    displaySpaceRequirements();
                    updateStartButton();
                    saveClientState(); // Save successful state
                    showSuccess(`Found ${foundZips.length} ZIP files`);
                } else {
                    foundZips = [];
                    spaceInfo = {};
                    displayFoundZips();
                    displaySpaceRequirements();
                    updateStartButton();
                    saveClientState();
                    showError(result.message || 'Invalid path');
                }
            } catch (error) {
                foundZips = [];
                displayFoundZips();
                updateStartButton();
                saveClientState();
                showError(`Error validating path: ${error.message}`);
            }
        }

        // Display found ZIP files
        function displayFoundZips() {
            const fileList = document.getElementById('file-list');
            const zipList = document.getElementById('zip-list');
            
            if (foundZips.length === 0) {
                fileList.style.display = 'none';
                return;
            }
            
            zipList.innerHTML = foundZips.map(zip => `
                <div class="zip-item">
                    <span class="zip-name">${zip.name}</span>
                    <span class="zip-size">${formatSize(zip.size || 0)}</span>
                </div>
            `).join('');
            
            fileList.style.display = 'block';
        }

        // Display disk space requirements
        function displaySpaceRequirements() {
            const fileList = document.getElementById('file-list');
            
            if (!spaceInfo || !spaceInfo.zip_size_gb) {
                return;
            }
            
            const spaceWarning = spaceInfo.space_sufficient ? '' : 'style="color: #dc3545; font-weight: bold;"';
            const spaceIcon = spaceInfo.space_sufficient ? '‚úÖ' : '‚ö†Ô∏è';
            const isLowSpace = spaceInfo.available_space_gb < 50;
            const lowSpaceWarning = isLowSpace ? 'style="color: #ffc107; font-weight: bold;"' : '';
            
            let confirmationNeeded = '';
            if (!spaceInfo.space_sufficient) {
                confirmationNeeded = `
                    <div style="margin-top: 12px; padding: 8px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="confirm-insufficient-space" style="margin: 0;">
                            <span style="font-size: 0.9rem;">I understand the risks and want to proceed anyway</span>
                        </label>
                    </div>
                `;
            } else if (isLowSpace) {
                confirmationNeeded = `
                    <div style="margin-top: 12px; padding: 8px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="confirm-low-space" style="margin: 0;">
                            <span style="font-size: 0.9rem;">I acknowledge the low disk space warning</span>
                        </label>
                    </div>
                `;
            }
            
            const spaceHtml = `
                <div class="space-requirements" style="margin-top: 16px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid ${spaceInfo.space_sufficient ? '#28a745' : '#dc3545'};">
                    <div style="font-weight: 600; margin-bottom: 8px;">${spaceIcon} Disk Space Requirements</div>
                    <div style="font-size: 0.9rem; color: #495057;">
                        ‚Ä¢ ZIP files: ${spaceInfo.zip_size_gb.toFixed(1)} GB<br>
                        ‚Ä¢ Extraction needs: ${spaceInfo.extraction_space_gb.toFixed(1)} GB<br>
                        ‚Ä¢ Available space: ${spaceInfo.available_space_gb.toFixed(1)} GB<br>
                        ${isLowSpace && spaceInfo.space_sufficient ? `<span ${lowSpaceWarning}>‚ö†Ô∏è Warning: Low disk space (< 50 GB)</span><br>` : ''}
                        <span ${spaceWarning}>
                            ${spaceInfo.space_sufficient ? '‚úÖ Sufficient space available' : '‚ö†Ô∏è Insufficient disk space!'}
                        </span>
                    </div>
                    ${confirmationNeeded}
                </div>
            `;
            
            // Add space info to file list
            fileList.insertAdjacentHTML('beforeend', spaceHtml);
            
            // Add event listeners for confirmation checkboxes
            const insufficientSpaceCheckbox = document.getElementById('confirm-insufficient-space');
            const lowSpaceCheckbox = document.getElementById('confirm-low-space');
            
            if (insufficientSpaceCheckbox) {
                insufficientSpaceCheckbox.addEventListener('change', updateStartButton);
            }
            if (lowSpaceCheckbox) {
                lowSpaceCheckbox.addEventListener('change', updateStartButton);
            }
        }

        // Update start button state
        function updateStartButton() {
            const startBtn = document.getElementById('start-btn');
            const validSource = foundZips.length > 0;
            const validExport = exportPath;
            const sufficientSpace = !spaceInfo.extraction_space_gb || spaceInfo.space_sufficient;
            const isLowSpace = spaceInfo.available_space_gb && spaceInfo.available_space_gb < 50;
            
            // Check if user has confirmed warnings
            const insufficientSpaceConfirmed = !document.getElementById('confirm-insufficient-space') || 
                                              document.getElementById('confirm-insufficient-space').checked;
            const lowSpaceConfirmed = !document.getElementById('confirm-low-space') || 
                                     document.getElementById('confirm-low-space').checked;
            
            const allConfirmed = insufficientSpaceConfirmed && lowSpaceConfirmed;
            
            if (validSource && validExport && (sufficientSpace || allConfirmed)) {
                startBtn.disabled = false;
                startBtn.textContent = 'Start Restructuring';
                startBtn.style.backgroundColor = '#007bff';
            } else {
                startBtn.disabled = true;
                startBtn.style.backgroundColor = '#6c757d';
                
                // Show specific warning messages
                if (validSource && validExport && !sufficientSpace && !insufficientSpaceConfirmed) {
                    startBtn.textContent = '‚ö†Ô∏è Confirm Insufficient Space';
                } else if (validSource && validExport && isLowSpace && !lowSpaceConfirmed) {
                    startBtn.textContent = '‚ö†Ô∏è Acknowledge Low Space';
                } else if (!validSource) {
                    startBtn.textContent = 'Select Source Folder';
                } else if (!validExport) {
                    startBtn.textContent = 'Select Export Folder';
                } else {
                    startBtn.textContent = 'Start Restructuring';
                }
            }
        }

        // Choose output folder
        function chooseOutputFolder() {
            const currentPath = document.getElementById('output-folder').value;
            const newPath = prompt('Enter output folder path:', currentPath || getDefaultOutputPath());
            
            if (newPath) {
                document.getElementById('output-folder').value = newPath;
                updateStartButton();
            }
        }

        // Start processing with proper paths
        async function startProcessing() {
            if (!sourcePath || !exportPath) {
                showError('Please select both source and export folders');
                return;
            }

            const isDryRun = document.getElementById('dry-run').checked;
            const verifyFiles = document.getElementById('verify-files').checked;
            const conflictMode = document.querySelector('input[name="conflict"]:checked').value;

            // Save state before starting
            saveClientState();

            try {
                const response = await fetch('/start-processing', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_path: sourcePath,
                        output_path: exportPath,
                        dry_run: isDryRun,
                        verify: verifyFiles,
                        conflict_mode: conflictMode
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    currentOperation = result.operation_id;
                    saveClientState(); // Save with operation ID
                    showProgressInterface();
                    startProgressMonitoring();
                } else if (result.active_operation_id) {
                    // Another operation is running - switch to it
                    showError('Switching to existing operation...', 2000);
                    currentOperation = result.active_operation_id;
                    saveClientState();
                    showProgressInterface();
                    startProgressMonitoring();
                } else {
                    showError(result.message || 'Failed to start processing');
                }
            } catch (error) {
                showError(`Error starting processing: ${error.message}`);
            }
        }

        // Progress monitoring with hang detection
        let consecutiveHangChecks = 0;
        let lastProgressValue = 0;
        let lastProgressTime = Date.now();
        
        function startProgressMonitoring() {
            if (progressInterval) clearInterval(progressInterval);
            consecutiveHangChecks = 0;
            lastProgressValue = 0;
            lastProgressTime = Date.now();
            
            progressInterval = setInterval(async () => {
                if (!currentOperation) return;
                
                try {
                    const response = await fetch(`/progress/${currentOperation}`);
                    const data = await response.json();
                    
                    // Check for hang detection
                    if (data.hang_detection) {
                        handleHangDetection(data.hang_detection, data.operation);
                    }
                    
                    updateProgress(data.operation);
                    
                    if (data.operation.status === 'completed') {
                        clearInterval(progressInterval);
                        
                        // Check if this was a dry run
                        const isDryRun = data.operation.dry_run || false;
                        if (isDryRun) {
                            showDryRunInterface(data.operation);
                        } else {
                            showCompletionInterface(data.operation);
                        }
                    } else if (data.operation.status === 'failed') {
                        clearInterval(progressInterval);
                        showError(data.operation.message || 'Processing failed');
                        showMainInterface();
                    } else if (data.operation.status === 'hung') {
                        clearInterval(progressInterval);
                        showHungOperationDialog(data.operation);
                    }
                } catch (error) {
                    console.error('Error fetching progress:', error);
                    // Increment consecutive error count
                    consecutiveHangChecks++;
                    
                    // If we've had 3+ consecutive errors, show connection issue warning
                    if (consecutiveHangChecks >= 3) {
                        showError('‚ö†Ô∏è Connection issues detected. The operation may still be running in the background.', 8000);
                        document.getElementById('current-operation').textContent = 'Connection Issues - Please wait...';
                    }
                }
            }, 2000); // Update every 2 seconds
        }
        
        function handleHangDetection(hangInfo, operation) {
            const minutesSinceActivity = hangInfo.minutes_since_activity;
            const currentProgress = operation.progress_percent || 0;
            const now = Date.now();
            
            // Reset consecutive hang checks if we got a successful response
            consecutiveHangChecks = 0;
            
            // Check if progress has actually advanced
            if (currentProgress > lastProgressValue) {
                lastProgressValue = currentProgress;
                lastProgressTime = now;
            } else {
                // No progress change - check time since last change
                const minutesSinceProgressChange = (now - lastProgressTime) / (1000 * 60);
                
                if (minutesSinceProgressChange > 3) { // 3 minutes without progress
                    showProgressStallWarning(minutesSinceProgressChange);
                }
            }
            
            // Show warning if backend reports long inactivity
            if (minutesSinceActivity > 2 && minutesSinceActivity <= 5) {
                showActivityWarning(minutesSinceActivity);
            }
        }
        
        function showProgressStallWarning(minutes) {
            const warningEl = document.getElementById('progress-warning');
            if (!warningEl) {
                const progressSection = document.querySelector('.progress-section');
                const warning = document.createElement('div');
                warning.id = 'progress-warning';
                warning.style.cssText = `
                    background: #fff3cd; 
                    border: 1px solid #ffeaa7; 
                    border-radius: 6px; 
                    padding: 12px; 
                    margin-top: 12px; 
                    color: #856404;
                    font-size: 0.9rem;
                `;
                warning.innerHTML = `
                    ‚ö†Ô∏è <strong>No progress detected for ${minutes.toFixed(1)} minutes</strong><br>
                    <small>The operation may be processing large files or experiencing delays. This is often normal for large datasets.</small>
                `;
                progressSection.appendChild(warning);
            }
        }
        
        function showActivityWarning(minutes) {
            const statusEl = document.getElementById('operation-status');
            if (statusEl) {
                statusEl.textContent = `Checking activity (${minutes.toFixed(1)}m since last update)`;
                statusEl.style.color = '#ffc107';
            }
        }
        
        function showHungOperationDialog(operation) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center;
                z-index: 10000; font-family: 'Poppins', sans-serif;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 12px; max-width: 500px; text-align: center;">
                    <h3 style="color: #dc3545; margin-bottom: 20px;">‚ö†Ô∏è Operation May Be Hung</h3>
                    <p style="margin-bottom: 20px; line-height: 1.5;">
                        The operation hasn't reported progress updates for several minutes. This could mean:
                        <br><br>
                        ‚Ä¢ Processing a very large file<br>
                        ‚Ä¢ System resource constraints<br>
                        ‚Ä¢ The operation has genuinely hung<br>
                    </p>
                    <div style="display: flex; gap: 12px; justify-content: center;">
                        <button onclick="this.closest('div[style*=position]').remove(); waitLonger()" 
                                style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Wait Longer
                        </button>
                        <button onclick="this.closest('div[style*=position]').remove(); forceCancel()" 
                                style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Force Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function waitLonger() {
            // Clear any warnings and restart monitoring
            const warning = document.getElementById('progress-warning');
            if (warning) warning.remove();
            
            lastProgressTime = Date.now(); // Reset progress timer
            startProgressMonitoring();
            showError('‚è≥ Continuing to wait for operation...', 3000);
        }
        
        async function forceCancel() {
            if (confirm('‚ö†Ô∏è Are you sure you want to force cancel this operation?\n\nThis will terminate all processing immediately.')) {
                await cancelOperation();
            }
        }

        // Update progress display
        function updateProgress(operation) {
            document.getElementById('current-operation').textContent = operation.current_operation || 'Processing...';
            document.getElementById('progress-fill').style.width = `${operation.progress_percent || 0}%`;
            document.getElementById('progress-text').textContent = `${(operation.progress_percent || 0).toFixed(1)}% - ${operation.current_file || 'Working...'}`;
            document.getElementById('operation-status').textContent = operation.status || 'Running';
            
            if (operation.stats) {
                document.getElementById('stats-display').style.display = 'grid';
                document.getElementById('total-files').textContent = (operation.stats.total_files || 0).toLocaleString();
                document.getElementById('processed-files').textContent = (operation.stats.copied_files || 0).toLocaleString();
                document.getElementById('skipped-files').textContent = (operation.stats.skipped_duplicates || 0).toLocaleString();
                document.getElementById('error-count').textContent = (operation.stats.errors || 0).toLocaleString();
            }
        }

        // Interface switching
        function showMainInterface() {
            document.getElementById('main-interface').style.display = 'block';
            document.getElementById('progress-interface').style.display = 'none';
            document.getElementById('completion-interface').style.display = 'none';
            document.getElementById('dry-run-interface').style.display = 'none';
        }
        
        async function proceedWithRealExecution() {
            if (!confirm('‚ö†Ô∏è Ready to proceed with REAL execution?\n\nThis will actually move and organize your files based on the dry run preview.\n\nContinue?')) {
                return;
            }
            
            // Get current settings
            const verifyFiles = document.getElementById('verify-files').checked;
            const conflictMode = document.querySelector('input[name="conflict"]:checked').value;
            
            try {
                const response = await fetch('/start-processing', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_path: sourcePath,
                        output_path: exportPath,
                        dry_run: false,  // REAL execution
                        verify: verifyFiles,
                        conflict_mode: conflictMode
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentOperation = result.operation_id;
                    showProgressInterface();
                    startProgressMonitoring();
                } else {
                    showError(result.message || 'Failed to start real execution');
                }
            } catch (error) {
                showError('Error starting real execution: ' + error.message);
            }
        }
        
        function showDryRunInterface(operation) {
            document.getElementById('main-interface').style.display = 'none';
            document.getElementById('progress-interface').style.display = 'none';
            document.getElementById('completion-interface').style.display = 'none';
            document.getElementById('dry-run-interface').style.display = 'block';
            
            // Populate dry run summary
            const summary = document.getElementById('dry-run-summary');
            const stats = operation.final_stats || {};
            const outputPath = exportPath || '/Volumes/Creator Pro/gDrive-test-output';
            
            // Calculate what would happen
            const wouldCopy = stats.total_files - stats.skipped_duplicates - stats.errors;
            const conflictFiles = stats.renamed_duplicates || 0;
            const duplicateFiles = stats.skipped_duplicates || 0;
            
            summary.innerHTML = `
                <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #2196f3;">
                    <h3 style="color: #1976d2; margin: 0 0 15px 0; font-size: 1.1rem;">üìã Dry Run Analysis Complete</h3>
                    <div style="background: white; padding: 15px; border-radius: 6px; border: 1px solid #bbdefb;">
                        <h4 style="margin: 0 0 10px 0; color: #333;">What Would Happen in Real Execution:</h4>
                        <div style="margin-left: 10px; line-height: 1.8;">
                            ‚úÖ <strong>${wouldCopy.toLocaleString()} files</strong> would be copied to:<br>
                            <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 0.85rem;">${outputPath}/Drive/</code><br><br>
                            
                            ${duplicateFiles > 0 ? `‚è≠Ô∏è <strong>${duplicateFiles.toLocaleString()} duplicate files</strong> would be skipped (already exist)<br>` : ''}
                            ${conflictFiles > 0 ? `üîÑ <strong>${conflictFiles.toLocaleString()} conflicting files</strong> would be renamed<br>` : ''}
                            ${stats.errors > 0 ? `‚ö†Ô∏è <strong>${stats.errors.toLocaleString()} files</strong> had errors and would be skipped<br>` : ''}
                            
                            üíæ <strong>Total data:</strong> ${((stats.copied_size || 0) / (1024**3)).toFixed(2)} GB would be organized
                        </div>
                    </div>
                    
                    ${stats.errors > 0 ? `
                        <div style="background: #fff3e0; padding: 12px; border-radius: 6px; margin-top: 15px; border-left: 3px solid #ff9800;">
                            ‚ö†Ô∏è <strong>Issues Found:</strong> ${stats.errors} files had problems. Check the preview logs for details.
                        </div>
                    ` : `
                        <div style="background: #e8f5e8; padding: 12px; border-radius: 6px; margin-top: 15px; border-left: 3px solid #4caf50;">
                            ‚úÖ <strong>No issues found!</strong> Your Google Drive structure is ready for reconstruction.
                        </div>
                    `}
                </div>
                
                <div class="completion-stats">
                    <div class="stat">
                        <div class="stat-value">${(stats.total_files || 0).toLocaleString()}</div>
                        <div class="stat-label">Files Analyzed</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${wouldCopy.toLocaleString()}</div>
                        <div class="stat-label">Would Copy</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${duplicateFiles.toLocaleString()}</div>
                        <div class="stat-label">Would Skip</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${stats.errors || 0}</div>
                        <div class="stat-label">Issues Found</div>
                    </div>
                </div>
            `;
        }

        function showProgressInterface() {
            document.getElementById('main-interface').style.display = 'none';
            document.getElementById('progress-interface').style.display = 'block';
            document.getElementById('completion-interface').style.display = 'none';
        }

        function showCompletionInterface(operation) {
            document.getElementById('main-interface').style.display = 'none';
            document.getElementById('progress-interface').style.display = 'none';
            document.getElementById('completion-interface').style.display = 'block';
            
            // Populate completion summary
            const summary = document.getElementById('completion-summary');
            const stats = operation.final_stats || {};
            const outputPath = exportPath || '/Volumes/Creator Pro/gDrive-test-output';
            
            summary.innerHTML = `
                <div style="background: #e8f5e8; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #28a745;">
                    <h3 style="color: #28a745; margin: 0 0 10px 0; font-size: 1.1rem;">üìÇ Your Files Are Ready!</h3>
                    <div style="background: white; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 0.9rem; word-break: break-all; border: 1px solid #d4edda;">
                        <strong>Location:</strong> ${outputPath}<br>
                        <strong>Main Folder:</strong> ${outputPath}/Drive/
                    </div>
                    <p style="margin: 10px 0 0 0; font-size: 0.9rem; color: #495057;">
                        ‚ú® Your Google Drive structure has been perfectly recreated in the "Drive" folder above!
                    </p>
                </div>
                
                <div class="completion-stats">
                    <div class="stat">
                        <div class="stat-value">${(stats.total_files || 0).toLocaleString()}</div>
                        <div class="stat-label">Files Processed</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${(stats.copied_files || 0).toLocaleString()}</div>
                        <div class="stat-label">Files Organized</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${((stats.copied_size || 0) / (1024**3)).toFixed(2)} GB</div>
                        <div class="stat-label">Data Processed</div>
                    </div>
                </div>
                <p>Your Google Drive has been successfully organized!</p>
            `;
        }

        // Utility functions
        function populateDefaultOutputPath() {
            const platform = navigator.platform.toLowerCase();
            let defaultPath;
            
            if (platform.includes('mac')) {
                defaultPath = '/Users/' + (process.env.USER || 'your-username') + '/Desktop/Google Drive Organized';
            } else if (platform.includes('win')) {
                defaultPath = 'C:\\Users\\your-username\\Desktop\\Google Drive Organized';
            } else {
                defaultPath = '/home/your-username/Desktop/Google Drive Organized';
            }
            
            document.getElementById('output-folder').value = defaultPath;
            updateStartButton();
        }

        function getDefaultOutputPath() {
            return document.getElementById('output-folder').value;
        }

        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function showError(message, duration = 5000) {
            document.getElementById('error-message').textContent = message;
            document.getElementById('error-toast').style.display = 'block';
            setTimeout(() => hideError(), duration);
        }

        function showSuccess(message) {
            // Could add success toast, for now just console
            console.log('Success:', message);
        }

        function hideError() {
            document.getElementById('error-toast').style.display = 'none';
        }

        function showLogs() {
            if (currentOperation) {
                window.open(`/logs/${currentOperation}`, '_blank');
            }
        }

        async function cancelOperation() {
            if (!currentOperation) {
                showError('No operation to cancel');
                return;
            }
            
            if (!confirm('‚ö†Ô∏è Are you sure you want to cancel the current operation?\n\nThis will stop all processing and return to the main screen.')) {
                return;
            }
            
            try {
                const response = await fetch(`/cancel/${currentOperation}`, { method: 'POST' });
                const result = await response.json();
                
                if (result.success) {
                    // Stop progress monitoring
                    if (progressInterval) {
                        clearInterval(progressInterval);
                        progressInterval = null;
                    }
                    
                    // Reset current operation
                    currentOperation = null;
                    
                    // Show success message
                    showSuccess('‚úÖ Operation cancelled successfully');
                    
                    // Return to main interface for fresh start
                    showMainInterface();
                    
                    // Clear any form data to start completely fresh
                    sourcePath = '';
                    exportPath = '';
                    document.getElementById('folder-path').value = '';
                    document.getElementById('export-path').value = '';
                    updatePathDisplay('source-path-display', '');
                    updatePathDisplay('export-path-display', '');
                    updateStartButton();
                    
                    console.log('‚úÖ Reset to fresh state after cancellation');
                } else {
                    showError('Failed to cancel operation: ' + (result.message || 'Unknown error'));
                }
            } catch (error) {
                showError('Error cancelling operation: ' + error.message);
                // Still try to reset the interface
                if (progressInterval) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
                currentOperation = null;
                showMainInterface();
            }
        }

        async function openOutputFolder() {
            const outputPath = exportPath || '/Volumes/Creator Pro/gDrive-test-output';
            
            // Method 1: Try server-side folder opening (works because server runs locally)
            try {
                const response = await fetch('/open-folder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: outputPath })
                });
                
                const result = await response.json();
                if (result.success) {
                    // Success! Folder should be open now
                    showSuccessMessage('üìÅ Folder opened successfully!\n\nYour organized files should now be visible in your file manager.');
                    return;
                } else {
                    console.log('Server-side open failed:', result.message);
                }
            } catch (e) {
                console.log('Server-side open error:', e);
            }
            
            // Method 2: Try File System Access API (Chrome/Edge only)
            if ('showDirectoryPicker' in window) {
                try {
                    showDirectoryPickerInstructions(outputPath);
                    return;
                } catch (e) {
                    console.log('Directory picker not available:', e);
                }
            }
            
            // Method 3: Fallback to instructions
            navigator.clipboard.writeText(outputPath).then(() => {
                showDetailedFolderInstructions(outputPath, true);
            }).catch(() => {
                showDetailedFolderInstructions(outputPath, false);
            });
        }
        
        function showSuccessMessage(message) {
            // Create a simple success modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center;
                z-index: 10000; font-family: 'Poppins', sans-serif;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white; padding: 30px; border-radius: 12px; max-width: 400px;
                text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            `;
            
            content.innerHTML = `
                <h3 style="color: #28a745; margin-bottom: 15px;">‚úÖ Success!</h3>
                <p style="margin-bottom: 20px; line-height: 1.5;">${message.replace('\n', '<br>')}</p>
                <button onclick="this.closest('div[style*="position: fixed"]').remove()" 
                        style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    Great!
                </button>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Auto-close after 3 seconds
            setTimeout(() => {
                if (modal.parentNode) modal.remove();
            }, 3000);
        }
        
        function showDirectoryPickerInstructions(outputPath) {
            const instructions = `
üéØ To view your organized files:

1. Click the button below to open the file picker
2. Navigate to and select this folder:
   ${outputPath}
3. Your organized Drive files are in the "Drive" subfolder

Alternatively, use the manual instructions that will appear next.
            `;
            
            if (confirm(instructions + '\n\nClick OK to open file picker, Cancel for manual instructions')) {
                try {
                    safeShowDirectoryPicker().then(dirHandle => {
                        alert('Great! You can now browse your organized files in the selected folder.');
                    }).catch(e => {
                        navigator.clipboard.writeText(outputPath);
                        showDetailedFolderInstructions(outputPath, true);
                    });
                } catch (e) {
                    navigator.clipboard.writeText(outputPath);
                    showDetailedFolderInstructions(outputPath, true);
                }
            } else {
                navigator.clipboard.writeText(outputPath);
                showDetailedFolderInstructions(outputPath, true);
            }
        }
        
        function showDetailedFolderInstructions(outputPath, clipboardSuccess) {
            const clipboardStatus = clipboardSuccess ? 'üìã Path copied to clipboard!' : 'üìã Could not copy to clipboard';
            
            const instructions = `
üéâ Your Google Drive has been successfully reorganized!

üìÇ ORGANIZED FILES LOCATION:
${outputPath}

${clipboardStatus}

üöÄ HOW TO OPEN THE FOLDER:

üçé macOS:
1. Open Finder
2. Press Cmd+Shift+G (or Go > Go to Folder)
3. Paste the path and press Enter
4. Or try: open "${outputPath}" in Terminal

ü™ü Windows:
1. Open File Explorer (Windows key + E)
2. Click address bar or press Ctrl+L
3. Paste the path and press Enter
4. Or try: explorer "${outputPath}" in Command Prompt

üêß Linux:
1. Open your file manager
2. Press Ctrl+L (or go to address bar)
3. Paste the path and press Enter
4. Or try: xdg-open "${outputPath}" in Terminal

üìÅ YOUR FILES ARE ORGANIZED IN:
${outputPath}/Drive/

üîç Look for the main "Drive" folder - that contains your organized Google Drive structure!
            `;
            
            // Create a better modal instead of alert
            showInstructionsModal(instructions, outputPath);
        }
        
        function showInstructionsModal(instructions, outputPath) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                font-family: 'Poppins', sans-serif;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 12px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            `;
            
            modalContent.innerHTML = `
                <h2 style="color: #28a745; margin-bottom: 20px; font-size: 1.5rem;">üéâ Processing Complete!</h2>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; font-family: monospace; font-size: 0.9rem; word-break: break-all;">
                    <strong>Output Location:</strong><br>
                    ${outputPath}
                </div>
                <pre style="white-space: pre-wrap; font-size: 0.85rem; line-height: 1.4; color: #333;">${instructions}</pre>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button onclick="copyPathAgain('${outputPath}')" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer;">üìã Copy Path Again</button>
                    <button onclick="this.closest('div[style*="position: fixed"]').remove()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer;">Close</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        function copyPathAgain(path) {
            navigator.clipboard.writeText(path).then(() => {
                alert('üìã Path copied to clipboard!');
            }).catch(() => {
                alert('‚ö†Ô∏è Could not copy to clipboard. Please manually copy:\n' + path);
            });
        }

        function downloadLogs() {
            if (currentOperation) {
                window.open(`/logs/${currentOperation}?download=true`, '_blank');
            }
        }

        async function cleanupTempFiles() {
            if (!sourcePath) {
                alert('No source path available for cleanup');
                return;
            }
            
            if (!confirm('This will remove all temporary extraction files from your source folder. Continue?')) {
                return;
            }
            
            try {
                // Call server to clean up temp files
                const response = await fetch('/cleanup-temp', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source_path: sourcePath })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert('‚úÖ Cleanup completed successfully!\n\n' + (result.message || 'Temporary files have been moved to trash.'));
                } else {
                    alert('‚ö†Ô∏è Cleanup failed: ' + (result.message || 'Unknown error'));
                }
            } catch (error) {
                alert('‚ö†Ô∏è Cleanup error: ' + error.message);
            }
        }
        
        function startOver() {
            currentOperation = null;
            foundZips = [];
            sourcePath = '';
            exportPath = '';
            document.getElementById('dry-run').checked = true;
            updatePathDisplay('path-display', '');
            updatePathDisplay('export-path-display', '');
            displayFoundZips();
            updateStartButton();
            showMainInterface();
        }

        // Path validation functions are called directly from UI actions
    </script>
</body>
</html>