{% extends "layout.html" %}

{% block content %}
<!-- Main Interface -->
<div class="interface" id="main-interface">
    <div class="panel-grid">
        <!-- Left Panel: File Selection -->
        <div class="panel">
            <div class="panel-header">
                <h2>Select Source Folder</h2>
                <p class="step-label">Step 1: üìÅ Add path to Takeout.zip files</p>
            </div>
            
            <div class="file-actions">
                <input type="text" id="folder-path" placeholder="Enter folder path or use buttons below..." 
                       style="width: 100%; padding: 12px; margin-bottom: 12px; border: 1px solid #dee2e6; border-radius: 6px; font-family: 'Poppins', sans-serif;" 
                       oninput="validatePath()">
                <button type="button" class="btn-primary" onclick="selectTakeoutFolder()">
                    Select Takeout Folder
                </button>
                <div class="path-display" id="path-display">
                    <div class="path-label-header">Selected Path:</div>
                    <div class="path-label" id="source-path-placeholder">No path selected</div>
                </div>
            </div>
            
            <!-- Found ZIP files list -->
            <div class="file-list" id="file-list" style="display: none;">
                <h3>üìÅ Found ZIP Files</h3>
                <div class="zip-list" id="zip-list">
                    <!-- ZIP files will be populated here -->
                </div>
            </div>
        </div>

        <!-- Right Panel: Settings -->
        <div class="panel">
            <div class="panel-header">
                <h2>Configure Output Settings</h2>
                <p class="step-label">Step 2: üîß Build Settings</p>
            </div>
            
            <div class="settings-form">
                <div class="setting-item">
                    <label class="checkbox-row" for="dry-run">
                        <input type="checkbox" id="dry-run">
                        <span class="checkbox-label">‚ùå Dry Run (Preview Only)</span>
                    </label>
                    <div style="margin-left: 30px; margin-top: 8px; font-size: 0.85rem; color: #6c757d; line-height: 1.4;">
                        üìã Shows what would happen without moving files<br>
                        ‚ö° Fast preview to verify your setup is correct<br>
                        üîç Detects conflicts and issues before real execution
                    </div>
                </div>
                
                <div class="setting-item">
                    <label class="checkbox-row" for="verify-files">
                        <input type="checkbox" id="verify-files">
                        <span class="checkbox-label">üîê File Verification (Recommended)</span>
                    </label>
                    <div style="margin-left: 30px; margin-top: 8px; font-size: 0.85rem; color: #6c757d; line-height: 1.4;">
                        üõ°Ô∏è Verifies each file with hash checking after copy<br>
                        ‚è±Ô∏è Takes longer but ensures 100% data integrity<br>
                        üíé Recommended for important files (300GB+ datasets)
                    </div>
                </div>
                
                <div class="setting-item">
                    <h3>üìã Handle File Conflicts</h3>
                    <div class="conflict-options">
                        <label class="radio-row" for="conflict-skip">
                            <input type="radio" id="conflict-skip" name="conflict" value="skip">
                            <span class="radio-label">Skip Duplicates</span>
                        </label>
                        <label class="radio-row" for="conflict-rename">
                            <input type="radio" id="conflict-rename" name="conflict" value="rename" checked>
                            <span class="radio-label">Rename (auto-suffix)</span>
                        </label>
                    </div>
                </div>
                
                <div class="output-section">
                    <p class="step-label">Step 3:  üíæ Select file export location</p>
                    <input type="text" id="export-path" placeholder="Enter export path or use button below..." 
                           style="width: 100%; padding: 12px; margin-bottom: 12px; border: 1px solid #dee2e6; border-radius: 6px; font-family: 'Poppins', sans-serif;" 
                           oninput="validateExportPath()">
                    <button type="button" class="btn-primary" onclick="selectExportFolder()">
                        Select Export Folder
                    </button>
                    <div class="path-display" id="export-path-display">
                        <div class="path-label-header">Selected Export Path:</div>
                        <div class="path-label" id="export-path-placeholder">No export path selected</div>
                    </div>
                </div>
                
                <button type="button" class="btn-action" id="start-btn" 
                        onclick="startProcessing()" disabled>
                    Start Restructuring
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Dry Run Results Interface -->
<div class="interface" id="dry-run-interface" style="display: none;">
    <div class="dry-run-panel">
        <div class="panel-header">
            <h2>üìã Dry Run Results</h2>
            <p>Preview of what will happen (no files moved yet)</p>
        </div>
        
        <div class="dry-run-summary" id="dry-run-summary">
            <!-- Dry run results will be populated here -->
        </div>
        
        <div class="action-buttons">
            <button type="button" class="btn-primary" onclick="executeActualRun()">
                Execute Real Run
            </button>
            <button type="button" class="btn" onclick="backToSettings()">
                Modify Settings
            </button>
        </div>
    </div>
</div>

<!-- Include partials -->
{% include "partials/progress.html" %}
{% include "partials/complete.html" %}
{% include "partials/errors.html" %}
{% include "partials/logs.html" %}
{% endblock %}

{% block scripts %}
<script>
// Global state
let currentOperation = null;
let progressInterval = null;
let foundZips = [];
let spaceInfo = {};
let sourcePath = '';
let exportPath = '';
let isPickerActive = false;  // Track if file picker is open

// Configuration constants for hang detection and recovery
const INACTIVITY_WARN_MIN = 5;   // Show warning after 5 minutes of no activity
const INACTIVITY_FAIL_MIN = 10;  // Show failure UI after 10 minutes of no activity
const OPERATION_FAIL_MIN = 20;   // Hard stop operation after 20 minutes

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    // setupDropZone(); // Drag and drop disabled
    updateStartButton();
    setupFormInteractions();
    loadUserPaths();
    checkForRecovery();
});

// Load user paths from server
async function loadUserPaths() {
    try {
        const response = await fetch('/user-paths');
        if (response.ok) {
            window.userPaths = await response.json();
            console.log('Loaded user paths:', window.userPaths);
            
            // Update default paths in UI
            updateDefaultPaths();
        } else {
            console.warn('Failed to load user paths from server');
            // Fallback to basic defaults
            window.userPaths = {
                platform: 'Unknown',
                defaultSource: '/Users/Downloads/Takeout',
                defaultOutput: '/Users/Desktop/Drive Export'
            };
        }
    } catch (error) {
        console.error('Error loading user paths:', error);
        window.userPaths = {
            platform: 'Unknown',
            defaultSource: '/Users/Downloads/Takeout',
            defaultOutput: '/Users/Desktop/Drive Export'
        };
    }
}

function updateDefaultPaths() {
    const folderPathInput = document.getElementById('folder-path');
    const exportPathInput = document.getElementById('export-path');
    const exportPathPlaceholder = document.getElementById('export-path-placeholder');
    
    if (folderPathInput && !folderPathInput.value) {
        folderPathInput.placeholder = `e.g., ${window.userPaths.defaultSource}`;
    }
    
    if (exportPathInput && !exportPathInput.value) {
        exportPathInput.placeholder = `e.g., ${window.userPaths.defaultOutput}`;
    }
    
    if (exportPathPlaceholder && exportPath === '') {
        exportPathPlaceholder.textContent = 'No export path selected';
    }
}

// Setup drag and drop zone - now disabled
function setupDropZone() {
    // Drag and drop functionality has been removed
    // Users should use the "Select Takeout Folder" button instead
}

// Enhanced path extraction from dropped items
async function extractPathFromDroppedItems(items) {
    console.log('Extracting path from', items.length, 'dropped items');
    
    const pathInfo = {
        detectedPath: null,
        files: [],
        directories: [],
        hasZipFiles: false,
        zipFiles: [],
        hasTakeoutStructure: false
    };
    
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        
        // For files
        if (item.kind === 'file') {
            const file = item.getAsFile();
            if (file) {
                console.log('Dropped file:', file.name, 'path:', file.webkitRelativePath);
                
                pathInfo.files.push({
                    name: file.name,
                    path: file.webkitRelativePath || file.name,
                    size: file.size,
                    isZip: file.name.toLowerCase().endsWith('.zip')
                });
                
                if (file.name.toLowerCase().endsWith('.zip')) {
                    pathInfo.hasZipFiles = true;
                    pathInfo.zipFiles.push(file.name);
                }
                
                if (file.name.toLowerCase().includes('takeout') || 
                    file.webkitRelativePath.toLowerCase().includes('takeout')) {
                    pathInfo.hasTakeoutStructure = true;
                }
                
                // Try to determine parent directory from file path
                if (file.webkitRelativePath) {
                    const parts = file.webkitRelativePath.split('/');
                    if (parts.length > 1) {
                        pathInfo.detectedPath = parts.slice(0, -1).join('/');
                    }
                }
            }
        }
        
        // For directories (using webkitGetAsEntry if available)
        if (item.webkitGetAsEntry) {
            const entry = item.webkitGetAsEntry();
            if (entry && entry.isDirectory) {
                console.log('Dropped directory:', entry.fullPath);
                pathInfo.directories.push(entry.fullPath);
                
                if (!pathInfo.detectedPath) {
                    pathInfo.detectedPath = entry.fullPath;
                }
                
                if (entry.fullPath.toLowerCase().includes('takeout')) {
                    pathInfo.hasTakeoutStructure = true;
                }
            }
        }
    }
    
    console.log('Path extraction result:', pathInfo);
    
    // If we have a detected path, try to complete it via server
    if (pathInfo.detectedPath) {
        const analyzed = await analyzeDroppedFile(pathInfo);
        return analyzed;
    }
    
    return pathInfo;
}

// Analyze dropped file/directory and determine best path
async function analyzeDroppedFile(pathInfo) {
    console.log('Analyzing dropped file info:', pathInfo);
    
    // Try multiple path resolution strategies
    const candidates = [];
    
    if (pathInfo.detectedPath) {
        candidates.push(pathInfo.detectedPath);
        
        // Try some variations
        candidates.push(pathInfo.detectedPath.replace(/^\//, ''));  // Remove leading slash
        candidates.push('/' + pathInfo.detectedPath);  // Add leading slash
        
        // If it contains takeout, try parent directory
        if (pathInfo.detectedPath.toLowerCase().includes('takeout')) {
            const parts = pathInfo.detectedPath.split('/');
            candidates.push(parts.slice(0, -1).join('/'));
        }
    }
    
    // Try to resolve the best path
    for (const candidate of candidates) {
        const bestPath = await determineBestPath(candidate, pathInfo);
        if (bestPath) {
            pathInfo.detectedPath = bestPath;
            break;
        }
    }
    
    return pathInfo;
}

// Determine best path using server-side logic
async function determineBestPath(partialPath, pathInfo) {
    try {
        // First try completing the path
        const completedPath = await tryCompletePathOnServer(partialPath);
        if (completedPath) {
            return completedPath;
        }
        
        // If that fails, try directory resolution
        if (pathInfo.directories.length > 0) {
            const dirName = pathInfo.directories[0].split('/').pop();
            const resolvedPath = await tryResolveDirectoryPath(dirName, pathInfo);
            if (resolvedPath) {
                return resolvedPath;
            }
        }
        
        return null;
    } catch (error) {
        console.error('Error determining best path:', error);
        return null;
    }
}

// Show path detection dialog when ambiguous
function showPathDetectionDialog(suggestions) {
    const dialog = document.createElement('div');
    dialog.className = 'path-detection-dialog';
    dialog.innerHTML = `
        <div class="dialog-content">
            <h3>Multiple Path Options Found</h3>
            <p>We found several possible locations for your Takeout files:</p>
            <div class="path-options">
                ${suggestions.map((suggestion, i) => `
                    <label class="path-option">
                        <input type="radio" name="path-choice" value="${suggestion.path}" ${i === 0 ? 'checked' : ''}>
                        <div class="path-details">
                            <div class="path-text">${suggestion.path}</div>
                            <div class="path-confidence">Confidence: ${Math.round(suggestion.confidence * 100)}%</div>
                        </div>
                    </label>
                `).join('')}
            </div>
            <div class="dialog-actions">
                <button type="button" onclick="confirmPathChoice()" class="btn-primary">Use Selected Path</button>
                <button type="button" onclick="cancelPathChoice()" class="btn">Cancel</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(dialog);
}

function confirmPathChoice() {
    const selected = document.querySelector('input[name="path-choice"]:checked');
    if (selected) {
        const folderPathInput = document.getElementById('folder-path');
        if (folderPathInput) {
            folderPathInput.value = selected.value;
        }
        validatePath();
    }
    cancelPathChoice();
}

function cancelPathChoice() {
    const dialog = document.querySelector('.path-detection-dialog');
    if (dialog) {
        dialog.remove();
    }
}

// Try to complete partial path via server
async function tryCompletePathOnServer(partialPath) {
    try {
        const response = await fetch('/complete-path', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ partialPath })
        });
        
        if (response.ok) {
            const result = await response.json();
            if (result.success) {
                console.log('Server completed path:', partialPath, '->', result.completedPath);
                return result.completedPath;
            }
        }
    } catch (error) {
        console.error('Error completing path on server:', error);
    }
    
    return null;
}

// Try to resolve directory path via server
async function tryResolveDirectoryPath(directoryName, pathInfo) {
    try {
        const response = await fetch('/resolve-directory-path', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                directoryName,
                hasZipFiles: pathInfo.hasZipFiles,
                zipFiles: pathInfo.zipFiles,
                directories: pathInfo.directories,
                hasTakeoutStructure: pathInfo.hasTakeoutStructure
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            if (result.success) {
                console.log('Server resolved directory:', directoryName, '->', result.resolvedPath);
                return result.resolvedPath;
            }
        }
    } catch (error) {
        console.error('Error resolving directory path on server:', error);
    }
    
    return null;
}

// Continue with the rest of the JavaScript functions...
// [The script would continue with all the other functions from the original file]

// Folder selection using File System Access API
async function selectTakeoutFolder() {
    if (isPickerActive) {
        console.log('Picker already active, ignoring duplicate call');
        return;
    }
    
    try {
        isPickerActive = true;
        
        if ('showDirectoryPicker' in window) {
            console.log('Using File System Access API');
            const directoryHandle = await window.showDirectoryPicker();
            console.log('Selected directory handle:', directoryHandle);
            
            // Analyze the directory
            const analysis = await analyzeDirectoryHandle(directoryHandle);
            console.log('Directory analysis:', analysis);
            
            // Try to resolve the full system path
            const resolvedPath = await tryResolveDirectoryPath(directoryHandle.name, analysis);
            
            if (resolvedPath) {
                // Use the resolved system path
                document.getElementById('folder-path').value = resolvedPath;
                sourcePath = resolvedPath;
                await validatePath();
            } else {
                // Fallback: show warning about path resolution
                showError('Selected folder, but couldn\'t determine full system path. Please enter the full path manually.');
                document.getElementById('folder-path').focus();
            }
        } else {
            // Fallback for browsers without File System Access API
            showError('Please enter the folder path manually.');
            document.getElementById('folder-path').focus();
        }
    } catch (error) {
        if (error.name !== 'AbortError') {
            console.error('Error selecting folder:', error);
            showError('Failed to select folder. Please try entering the path manually.');
        } else {
            console.log('Folder selection cancelled by user');
        }
    } finally {
        isPickerActive = false;
    }
}

// Analyze directory handle from File System Access API
async function analyzeDirectoryHandle(directoryHandle) {
    const analysis = {
        hasZipFiles: false,
        zipFiles: [],
        directories: [],
        hasTakeoutStructure: false,
        fileCount: 0
    };
    
    try {
        for await (const [name, handle] of directoryHandle.entries()) {
            if (handle.kind === 'file') {
                analysis.fileCount++;
                if (name.toLowerCase().endsWith('.zip')) {
                    analysis.hasZipFiles = true;
                    analysis.zipFiles.push(name);
                }
                if (name.toLowerCase().includes('takeout')) {
                    analysis.hasTakeoutStructure = true;
                }
            } else if (handle.kind === 'directory') {
                analysis.directories.push(name);
                if (name.toLowerCase().includes('takeout')) {
                    analysis.hasTakeoutStructure = true;
                }
            }
        }
    } catch (error) {
        console.error('Error analyzing directory:', error);
    }
    
    return analysis;
}

// Similar function for export folder
async function selectExportFolder() {
    if (isPickerActive) {
        console.log('Picker already active, ignoring duplicate call');
        return;
    }
    
    try {
        isPickerActive = true;
        
        if ('showDirectoryPicker' in window) {
            const directoryHandle = await window.showDirectoryPicker();
            const folderName = directoryHandle.name;
            
            console.log('Selected folder name:', folderName);
            
            // Try to resolve the full system path
            const resolvedPath = await tryResolveDirectoryPath(folderName, {
                directories: [folderName],
                hasZipFiles: false,
                zipFiles: [],
                hasTakeoutStructure: false
            });
            
            if (resolvedPath) {
                // Use the resolved system path
                document.getElementById('export-path').value = resolvedPath;
                exportPath = resolvedPath;
                await validateExportPath();
            } else {
                // Try with default user paths
                const defaultPath = window.userPaths?.defaultOutput || '/Users/Desktop';
                const suggestedPath = `${defaultPath}/${folderName}`;
                document.getElementById('export-path').value = suggestedPath;
                exportPath = suggestedPath;
                await validateExportPath();
            }
        } else {
            showError('Please enter the export folder path manually.');
            document.getElementById('export-path').focus();
        }
    } catch (error) {
        if (error.name !== 'AbortError') {
            console.error('Error selecting export folder:', error);
            showError('Failed to select export folder.');
        }
    } finally {
        isPickerActive = false;
    }
}

// Removed popup dialog functions - no longer needed
// Export path is now handled directly with input field and validation

// Show success message
function showSuccessMessage(message) {
    const toast = document.createElement('div');
    toast.className = 'toast success-toast';
    toast.innerHTML = `
        <span>${message}</span>
        <button type="button" onclick="this.parentElement.remove()">√ó</button>
    `;
    
    document.body.appendChild(toast);
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
        if (toast.parentElement) {
            toast.remove();
        }
    }, 5000);
}

// Path validation
async function validatePath() {
    const folderPath = document.getElementById('folder-path').value.trim();
    const pathDisplay = document.getElementById('path-display');
    const pathPlaceholder = document.getElementById('source-path-placeholder');
    const fileList = document.getElementById('file-list');
    
    if (!folderPath) {
        pathPlaceholder.textContent = 'No path selected';
        fileList.style.display = 'none';
        sourcePath = '';
        foundZips = [];
        updateStartButton();
        return;
    }
    
    try {
        pathPlaceholder.textContent = 'Validating...';
        
        const response = await fetch('/validate-path', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: folderPath })
        });
        
        const result = await response.json();
        
        if (result.success) {
            sourcePath = result.path;
            foundZips = result.zip_files || [];
            spaceInfo = result.space_info || {};
            
            pathPlaceholder.textContent = sourcePath;
            pathDisplay.className = 'path-display success';
            
            // Show found ZIP files
            displayFoundZips(foundZips, spaceInfo);
        } else {
            pathPlaceholder.textContent = result.message || 'Invalid path';
            pathDisplay.className = 'path-display error';
            fileList.style.display = 'none';
            sourcePath = '';
            foundZips = [];
        }
    } catch (error) {
        console.error('Error validating path:', error);
        pathPlaceholder.textContent = 'Error validating path';
        pathDisplay.className = 'path-display error';
        fileList.style.display = 'none';
        sourcePath = '';
        foundZips = [];
    }
    
    updateStartButton();
}

// Validate export path
async function validateExportPath() {
    const exportPathInput = document.getElementById('export-path').value.trim();
    const pathDisplay = document.getElementById('export-path-display');
    const pathPlaceholder = document.getElementById('export-path-placeholder');
    
    if (!exportPathInput) {
        pathPlaceholder.textContent = 'No export path selected';
        pathDisplay.className = 'path-display';
        exportPath = '';
        updateStartButton();
        return;
    }
    
    try {
        pathPlaceholder.textContent = 'Validating...';
        
        // Validate and potentially create the path
        const response = await fetch('/validate-and-create-path', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                path: exportPathInput, 
                create: true, 
                type: 'directory' 
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            exportPath = result.path;
            pathPlaceholder.textContent = exportPath;
            pathDisplay.className = 'path-display success';
            
            if (result.created) {
                console.log(`Created output folder: ${exportPath}`);
            }
        } else {
            pathPlaceholder.textContent = result.error || 'Invalid path';
            pathDisplay.className = 'path-display error';
            exportPath = '';
        }
    } catch (error) {
        console.error('Error validating export path:', error);
        pathPlaceholder.textContent = 'Error validating path';
        pathDisplay.className = 'path-display error';
        exportPath = '';
    }
    
    updateStartButton();
}

// Display found ZIP files
function displayFoundZips(zips, spaceInfo) {
    const fileList = document.getElementById('file-list');
    const zipList = document.getElementById('zip-list');
    
    if (zips.length === 0) {
        // No files found - show error state
        fileList.className = 'file-list no-files';
        fileList.style.display = 'block';
        zipList.innerHTML = '<div style="text-align: center; padding: 20px; color: #721c24;">No ZIP files found in this directory</div>';
        return;
    }
    
    // Determine the appropriate state class
    let stateClass = 'files-found'; // Default to success
    
    // Check if files are valid Takeout files
    const validTakeoutFiles = zips.filter(zip => 
        zip.name.toLowerCase().includes('takeout') || 
        zip.name.match(/\d{14}/) // Google's timestamp format
    );
    
    if (validTakeoutFiles.length === 0) {
        // Files found but might not be Takeout files
        stateClass = 'files-warning';
    } else if (spaceInfo && spaceInfo.space_sufficient === false) {
        // Space issue
        stateClass = 'files-warning';
    }
    
    // Apply the state class
    fileList.className = `file-list ${stateClass}`;
    
    let html = '';
    let totalSize = 0;
    
    zips.forEach(zip => {
        const sizeGB = (zip.size / (1024**3)).toFixed(2);
        totalSize += zip.size;
        
        // Check if this looks like a valid Takeout file
        const isValidTakeout = zip.name.toLowerCase().includes('takeout') || zip.name.match(/\d{14}/);
        const itemClass = isValidTakeout ? '' : 'style="opacity: 0.8;"';
        
        html += `
            <div class="zip-item" ${itemClass}>
                <div class="zip-info">
                    <span class="zip-name">${zip.name}</span>
                    <span class="zip-size">${sizeGB} GB</span>
                </div>
            </div>
        `;
    });
    
    // Add space information if available
    if (spaceInfo && Object.keys(spaceInfo).length > 0) {
        const totalGB = (totalSize / (1024**3)).toFixed(2);
        const spaceClass = spaceInfo.space_sufficient ? 'space-ok' : 'space-warning';
        
        html += `
            <div class="space-info ${spaceClass}">
                <div class="space-summary">
                    <div>Total ZIP files: ${zips.length} (${totalGB} GB)</div>
                    ${spaceInfo.extraction_space_gb ? `<div>Estimated extraction space needed: ${spaceInfo.extraction_space_gb.toFixed(1)} GB</div>` : ''}
                    ${spaceInfo.available_space_gb ? `<div>Available space: ${spaceInfo.available_space_gb.toFixed(1)} GB</div>` : ''}
                    ${spaceInfo.space_sufficient === false ? '<div class="warning">‚ö†Ô∏è May not have enough space for extraction</div>' : ''}
                </div>
            </div>
        `;
    }
    
    zipList.innerHTML = html;
    fileList.style.display = 'block';
}

// Update start button state
function updateStartButton() {
    const startBtn = document.getElementById('start-btn');
    const canStart = sourcePath && exportPath && foundZips.length > 0;
    
    startBtn.disabled = !canStart;
    
    if (canStart) {
        startBtn.textContent = 'Start Restructuring';
        startBtn.className = 'btn-action';
    } else {
        startBtn.textContent = 'Select paths first';
        startBtn.className = 'btn-action disabled';
    }
}

// Setup form interactions
function setupFormInteractions() {
    // Export path input validation on Enter key
    const exportPathInput = document.getElementById('export-path');
    if (exportPathInput) {
        exportPathInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                validateExportPath();
            }
        });
        
        // Also validate on blur (when user clicks away)
        exportPathInput.addEventListener('blur', () => {
            if (exportPathInput.value.trim()) {
                validateExportPath();
            }
        });
    }
}

// Check for recovery on page load
async function checkForRecovery() {
    try {
        // Try to restore from server first (with retries)
        let serverRecovery = null;
        let retries = 3;
        
        while (retries > 0 && !serverRecovery) {
            try {
                const response = await fetch('/recovery-info');
                if (response.ok) {
                    serverRecovery = await response.json();
                    break;
                }
            } catch (error) {
                console.log(`Server recovery attempt failed (${retries} retries left):`, error);
                retries--;
                if (retries > 0) {
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second before retry
                }
            }
        }
        
        // If server recovery failed, try localStorage
        if (!serverRecovery && retries === 0) {
            console.warn('Could not connect to server for state recovery. Some features may be limited.');
            showError('Could not connect to server for state recovery. Some features may be limited.');
            
            // Try to restore from localStorage as fallback
            serverRecovery = restoreClientState();
        }
        
        if (serverRecovery && serverRecovery.hasActiveOperation) {
            console.log('Found active operation, starting recovery:', serverRecovery);
            // Show recovery interface or automatically resume
            if (confirm('Found an interrupted operation. Would you like to resume it?')) {
                resumeOperation(serverRecovery.activeOperation);
            }
        }
        
    } catch (error) {
        console.error('Error during recovery check:', error);
        // Try localStorage fallback
        const localRecovery = restoreClientState();
        if (localRecovery && localRecovery.hasActiveOperation) {
            if (confirm('Found interrupted operation data. Attempt recovery?')) {
                // Try to restart with saved parameters
                if (localRecovery.sourcePath) {
                    document.getElementById('folder-path').value = localRecovery.sourcePath;
                    validatePath();
                }
                if (localRecovery.exportPath) {
                    exportPath = localRecovery.exportPath;
                    document.getElementById('export-path').value = exportPath;
                    document.getElementById('export-path-placeholder').textContent = exportPath;
                }
            }
        }
    }
}

// Save client state to localStorage
function saveClientState() {
    const state = {
        timestamp: new Date().toISOString(),
        sourcePath: sourcePath,
        exportPath: exportPath,
        foundZips: foundZips,
        currentOperation: currentOperation,
        hasActiveOperation: !!currentOperation
    };
    
    try {
        localStorage.setItem('takeout_consolidator_state', JSON.stringify(state));
    } catch (error) {
        console.error('Failed to save client state:', error);
    }
}

// Restore client state from localStorage
function restoreClientState() {
    try {
        const stateStr = localStorage.getItem('takeout_consolidator_state');
        if (stateStr) {
            const state = JSON.parse(stateStr);
            
            // Check if state is recent (less than 24 hours old)
            const stateAge = Date.now() - new Date(state.timestamp).getTime();
            if (stateAge < 24 * 60 * 60 * 1000) { // 24 hours
                return state;
            } else {
                // Clean up old state
                localStorage.removeItem('takeout_consolidator_state');
            }
        }
    } catch (error) {
        console.error('Failed to restore client state:', error);
        localStorage.removeItem('takeout_consolidator_state');
    }
    
    return null;
}

// Resume operation
function resumeOperation(operationInfo) {
    if (!operationInfo || !operationInfo.id) {
        console.error('Invalid operation info for resume');
        return;
    }
    
    currentOperation = operationInfo.id;
    
    // Switch to progress interface
    showInterface('progress-interface');
    
    // Start monitoring progress
    startProgressMonitoring();
}

// Start processing
async function startProcessing() {
    if (!sourcePath || !exportPath || foundZips.length === 0) {
        showError('Please select both source and export paths first');
        return;
    }
    
    try {
        // Collect settings
        const settings = {
            takeout_path: sourcePath,
            export_path: exportPath,
            dry_run: document.getElementById('dry-run').checked,
            verify_files: document.getElementById('verify-files').checked,
            conflict_resolution: document.querySelector('input[name="conflict"]:checked').value
        };
        
        console.log('Starting processing with settings:', settings);
        
        // Save state before starting
        saveClientState();
        
        // Start processing
        const response = await fetch('/start-processing', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(settings)
        });
        
        const result = await response.json();
        
        if (result.success) {
            currentOperation = result.operation_id;
            
            // Switch to progress interface
            showInterface('progress-interface');
            
            // Start monitoring progress
            startProgressMonitoring();
        } else {
            showError(result.message || 'Failed to start processing');
        }
    } catch (error) {
        console.error('Error starting processing:', error);
        showError('Failed to start processing: ' + error.message);
    }
}

// Show specific interface
function showInterface(interfaceId) {
    const interfaces = document.querySelectorAll('.interface');
    interfaces.forEach(iface => {
        iface.style.display = iface.id === interfaceId ? 'block' : 'none';
    });
}

// Start progress monitoring
function startProgressMonitoring() {
    if (progressInterval) {
        clearInterval(progressInterval);
    }
    
    // Update progress immediately
    updateProgress();
    
    // Then update every second
    progressInterval = setInterval(updateProgress, 1000);
}

// Update progress
async function updateProgress() {
    if (!currentOperation) {
        console.log('No current operation, stopping progress monitoring');
        if (progressInterval) {
            clearInterval(progressInterval);
            progressInterval = null;
        }
        return;
    }
    
    try {
        const response = await fetch(`/progress/${currentOperation}`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('Progress update:', data);
        
        const operation = data.operation;
        const hangDetection = data.hang_detection;
        
        // Update progress display
        updateProgressDisplay(operation, hangDetection);
        
        // Check for completion or failure
        if (operation.status === 'completed') {
            console.log('Operation completed');
            showInterface('completion-interface');
            displayCompletionResults(operation);
            
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
            currentOperation = null;
            
            // Clear saved state
            localStorage.removeItem('takeout_consolidator_state');
            
        } else if (operation.status === 'failed' || operation.status === 'cancelled') {
            console.log('Operation failed or cancelled:', operation.status);
            showError(operation.message || `Operation ${operation.status}`);
            
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
            currentOperation = null;
            
            // Clear saved state
            localStorage.removeItem('takeout_consolidator_state');
        }
        
        // Update client state
        saveClientState();
        
    } catch (error) {
        console.error('Error updating progress:', error);
        
        // If we can't reach the server, there might be an issue
        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
            showError('Lost connection to server. Please check if the application is still running.');
            
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
        }
    }
}

// Update progress display
function updateProgressDisplay(operation, hangDetection) {
    // Update status mapping - no more "Idle" during operation
    const statusMap = {
        'starting': 'Starting...',
        'extracting': 'Extracting ZIP files...',
        'processing': 'Processing files...',
        'consolidating': 'Consolidating structure...',
        'completed': 'Completed',
        'failed': 'Failed',
        'cancelled': 'Cancelled',
        'hung': 'Operation may be stuck...'
    };
    
    const currentOp = document.getElementById('current-operation');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const operationStatus = document.getElementById('operation-status');
    
    // Update current operation text
    if (operation.current_operation) {
        currentOp.textContent = operation.current_operation;
    } else if (operation.current_file) {
        currentOp.textContent = `Processing: ${operation.current_file}`;
    } else {
        currentOp.textContent = statusMap[operation.status] || 'Processing...';
    }
    
    // Update progress bar
    const progress = Math.max(0, Math.min(100, operation.progress_percent || 0));
    progressFill.style.width = `${progress}%`;
    progressText.textContent = `${Math.round(progress)}% - ${statusMap[operation.status] || operation.status}`;
    operationStatus.textContent = operation.status;
    
    // Update statistics if available
    if (operation.stats) {
        const stats = operation.stats;
        const statsDisplay = document.getElementById('stats-display');
        
        document.getElementById('total-files').textContent = stats.total_files || 0;
        document.getElementById('processed-files').textContent = stats.copied_files || 0;
        document.getElementById('skipped-files').textContent = stats.skipped_duplicates || 0;
        document.getElementById('error-count').textContent = stats.errors || 0;
        
        statsDisplay.style.display = 'block';
    }
    
    // Handle hang detection
    if (hangDetection) {
        handleHangDetection(hangDetection, operation);
    }
}

// Handle hang detection
function handleHangDetection(hangDetection, operation) {
    const minutesSinceActivity = hangDetection.minutes_since_activity;
    
    if (minutesSinceActivity > OPERATION_FAIL_MIN) {
        // Hard stop - operation has been running too long
        console.warn(`Operation has been running for ${minutesSinceActivity} minutes, forcing failure`);
        showError(`Operation has been running for over ${OPERATION_FAIL_MIN} minutes and has been stopped. This may indicate an issue with the files or system.`);
        
        // Cancel the operation
        cancelOperation();
        
    } else if (minutesSinceActivity > INACTIVITY_FAIL_MIN) {
        // Show failure UI if no activity for too long
        console.warn(`No activity for ${minutesSinceActivity} minutes, showing failure warning`);
        
        if (!document.getElementById('hang-warning')) {
            const warningDiv = document.createElement('div');
            warningDiv.id = 'hang-warning';
            warningDiv.className = 'hang-warning';
            warningDiv.innerHTML = `
                <div class="warning-content">
                    ‚ö†Ô∏è The operation appears to be stuck (no activity for ${Math.round(minutesSinceActivity)} minutes).
                    <div class="warning-actions">
                        <button onclick="cancelOperation()" class="btn btn-small">Cancel Operation</button>
                        <button onclick="dismissHangWarning()" class="btn btn-small">Continue Waiting</button>
                    </div>
                </div>
            `;
            
            const progressInterface = document.getElementById('progress-interface');
            if (progressInterface) {
                progressInterface.appendChild(warningDiv);
            }
        }
        
    } else if (minutesSinceActivity > INACTIVITY_WARN_MIN) {
        // Show warning if no recent activity
        console.log(`No activity for ${minutesSinceActivity} minutes, showing warning`);
        
        if (!document.getElementById('hang-warning')) {
            const warningDiv = document.createElement('div');
            warningDiv.id = 'hang-warning';
            warningDiv.className = 'hang-info';
            warningDiv.innerHTML = `
                <div class="info-content">
                    ‚ÑπÔ∏è No activity for ${Math.round(minutesSinceActivity)} minutes. Large files may take time to process.
                    <button onclick="dismissHangWarning()" class="btn btn-small">OK</button>
                </div>
            `;
            
            const progressInterface = document.getElementById('progress-interface');
            if (progressInterface) {
                progressInterface.appendChild(warningDiv);
            }
        }
    } else {
        // Remove any existing warnings if activity is recent
        const existingWarning = document.getElementById('hang-warning');
        if (existingWarning) {
            existingWarning.remove();
        }
    }
}

// Dismiss hang warning
function dismissHangWarning() {
    const warning = document.getElementById('hang-warning');
    if (warning) {
        warning.remove();
    }
}

// Cancel operation
async function cancelOperation() {
    if (!currentOperation) {
        return;
    }
    
    try {
        const response = await fetch(`/cancel/${currentOperation}`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (result.success) {
            console.log('Operation cancelled successfully');
            showInterface('main-interface');
            
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
            
            currentOperation = null;
            
            // Clear saved state
            localStorage.removeItem('takeout_consolidator_state');
            
            // Remove any hang warnings
            dismissHangWarning();
            
        } else {
            showError('Failed to cancel operation: ' + (result.message || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error cancelling operation:', error);
        showError('Error cancelling operation: ' + error.message);
    }
}

// Display completion results
function displayCompletionResults(operation) {
    const completionSummary = document.getElementById('completion-summary');
    
    const stats = operation.stats || {};
    const duration = operation.end_time && operation.start_time 
        ? ((new Date(operation.end_time) - new Date(operation.start_time)) / 1000 / 60).toFixed(1)
        : 'Unknown';
    
    completionSummary.innerHTML = `
        <div class="completion-stats">
            <div class="stat-row">
                <span class="stat-label">Total Files:</span>
                <span class="stat-value">${stats.total_files || 0}</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Files Copied:</span>
                <span class="stat-value">${stats.copied_files || 0}</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Skipped (Duplicates):</span>
                <span class="stat-value">${stats.skipped_duplicates || 0}</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Errors:</span>
                <span class="stat-value">${stats.errors || 0}</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Duration:</span>
                <span class="stat-value">${duration} minutes</span>
            </div>
        </div>
        
        <div class="completion-message">
            <p>‚úÖ Your Google Drive structure has been successfully reconstructed!</p>
            <p>Files have been organized in: <strong>${exportPath}</strong></p>
        </div>
    `;
}

// Show logs
function showLogs() {
    const logsOverlay = document.getElementById('logs-overlay');
    if (logsOverlay) {
        logsOverlay.style.display = 'flex';
        refreshLogs();
    }
}

// Hide logs
function hideLogs() {
    const logsOverlay = document.getElementById('logs-overlay');
    if (logsOverlay) {
        logsOverlay.style.display = 'none';
    }
}

// Refresh logs
async function refreshLogs() {
    if (!currentOperation) {
        return;
    }
    
    try {
        const response = await fetch(`/logs/${currentOperation}`);
        const data = await response.json();
        
        const logsContent = document.getElementById('logs-content');
        if (logsContent && data.logs) {
            logsContent.innerHTML = data.logs.map(log => `
                <div class="log-entry ${log.type || 'info'}">
                    <span class="log-timestamp">${new Date(log.timestamp).toLocaleTimeString()}</span>
                    <span class="log-message">${log.message}</span>
                </div>
            `).join('');
            
            // Auto-scroll if enabled
            const autoScroll = document.getElementById('auto-scroll-logs');
            if (autoScroll && autoScroll.checked) {
                logsContent.scrollTop = logsContent.scrollHeight;
            }
        }
    } catch (error) {
        console.error('Error refreshing logs:', error);
    }
}

// Open output folder
async function openOutputFolder() {
    try {
        const response = await fetch('/open-folder', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: exportPath })
        });
        
        const result = await response.json();
        
        if (!result.success) {
            showError(result.message || 'Failed to open folder');
        }
    } catch (error) {
        console.error('Error opening folder:', error);
        showError('Error opening folder: ' + error.message);
    }
}

// Start over
function startOver() {
    // Reset state
    currentOperation = null;
    sourcePath = '';
    exportPath = '';
    foundZips = [];
    
    // Clear intervals
    if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
    }
    
    // Clear form
    document.getElementById('folder-path').value = '';
    document.getElementById('source-path-placeholder').textContent = 'No path selected';
    document.getElementById('file-list').style.display = 'none';
    
    // Reset export path
    document.getElementById('export-path').value = '';
    document.getElementById('export-path-placeholder').textContent = 'No export path selected';
    exportPath = '';
    
    // Clear saved state
    localStorage.removeItem('takeout_consolidator_state');
    
    // Show main interface
    showInterface('main-interface');
    
    updateStartButton();
}

// Error handling
function showError(message) {
    const errorToast = document.getElementById('error-toast');
    const errorMessage = document.getElementById('error-message');
    
    if (errorToast && errorMessage) {
        errorMessage.textContent = message;
        errorToast.style.display = 'block';
        
        // Auto-hide after 10 seconds
        setTimeout(() => {
            hideError();
        }, 10000);
    } else {
        // Fallback to alert if toast not available
        alert(message);
    }
}

function hideError() {
    const errorToast = document.getElementById('error-toast');
    if (errorToast) {
        errorToast.style.display = 'none';
    }
}

// Additional utility functions
function cleanupTempFiles() {
    fetch('/cleanup-temp', { method: 'POST' })
        .then(response => response.json())
        .then(result => {
            if (result.success) {
                console.log('Temp files cleaned up successfully');
            } else {
                showError('Failed to cleanup temp files: ' + result.message);
            }
        })
        .catch(error => {
            console.error('Error cleaning up temp files:', error);
            showError('Error cleaning up temp files: ' + error.message);
        });
}

function downloadLogs() {
    if (currentOperation) {
        window.open(`/logs/${currentOperation}?download=true`, '_blank');
    }
}

// Handle page visibility changes
document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'visible' && currentOperation) {
        // Page became visible again, refresh progress
        updateProgress();
    }
});

// Handle page beforeunload
window.addEventListener('beforeunload', function(e) {
    if (currentOperation) {
        // Save state before leaving
        saveClientState();
        
        // Show confirmation dialog
        e.preventDefault();
        e.returnValue = 'Processing is still in progress. Are you sure you want to leave?';
        return e.returnValue;
    }
});
</script>
{% endblock %}
